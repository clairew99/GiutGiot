# 배포 가이드

# 🔎 Stacks

### Management Tool

`Jira` `Mattermost` `Discord` `Notion` `GitLab` `Figma` `ERDCloud`

### IDE

`VSCode` `Intellij` `Android Studio`

### Infra

`EC2` `Docker(25.0.4)` `Ubuntu(20.04.6)` `Jenkins(2.469)`

### Frontend

`HTML5` `CSS` `JS` `React(18.2.0)` `Axios(1.6.8)` `React-Router-Dom(6.22.3)` `Node(20.11.1)` `React-Dom(18.2.0)` `Zustand(4.5.2)` `Styled-Components(6.1.8)` 

### Backend

`Java(17)` `Spring boot(3.2.3)` `Spring Date JPA(3.2.3)` `jjwt(0.12.5)` `QueryDsl(5.0.0)` `Mysql(8.0)` `Redis(7.2.4)` `Elasticsearch(8.12.2)`

### AI

`Python(3.11)` `FastAPI(0.110.0)` `uvicorn(0.29.0)` `tensorflow(2.15.0)` `konply(0.6.0)` `pandas(2.2.1)` `numpy(1.26.4)` `scikit-learn(1.12.0)` `jupyter hub(4.0.2)`

# 🗃️ Build & Distribute

## Backend Build

### application.yml

```
spring:
  datasource:
    driver-class-name: {DB Driver}
    url: {DB URL}
    username: {DB username}
    password: {DB password}
    hikari:
      maximum-pool-size: {Pool SIze}
  jpa:
    hibernate:
      ddl-auto: update
    defer-datasource-initialization: true
  sql:
    init:
      mode: always
  servlet:
    multipart:
      max-file-size: {업로드 용량 제한}
      max-request-size: {업로드 용량 제한}
  jackson:
    time-zone: {타임존 세팅}

  jwt:
    header: {JWT hearder 세팅}
    secret: {JWT Secret 세팅}
    access-token-validity-in-seconds: {access token 유효기간 설정}
    refresh-token-validity-in-seconds: {refresh token 유효기간 설정}
  elasticsearch:
    uris: {Elascitsearech URL}
    password: {Elasticsearch password}
    username: {Elasticsearch username}

redis:
  master:
    host: {Redis URL}
    port: {Redis port}
  password: {Redis password}

server:
  port: {Server port}
  servlet:
    context-path: {Server context path}

management:
  endpoints:
    enabled-by-default: false
  endpoint:
    health:
      enabled: true

kakao:
  api:
    secret: {kakao REST api key}
  login:
    secret: {kakao REST api key}
    redirect: {kakao login redirect URL}
    tmp-path: {kakao login tmp-path}
swagger:
  local: {swagger local URL}
  production: {swagger production URL}

feign :
  fast-api:
    url: {fast-api URL}
  kakao:
    token: {kakao token URL}
    authorize: {kakao authorize URL}
    user: {kakao user URL}

cloud:
  aws:
    s3:
      bucket: {bucket name}
    credentials:
      access-key: {aws s3 credentials access-key}
      secret-key: {aws s3 credentials secret-key}
    region:
      static: {aws s3 region}
      auto: false
    stack:
      auto: false
    prefix: {aws s3 bucket URL}

default:
  profile:
    image:
      url: {default profile image url}

```

### IDE 및 환경설정

```
1. jdk 17 다운로드 및 환경변수 설정
2. git clone 후 backend 폴더를 Intellij에서 Open하여 가져오기
3. Intellij - File - Project Structure - Project에서 SDK를 17버전으로 맞추기
4. Intellij - File - Settings - Gradle에서 Gradle JVM을 [1]에서 추가한 환경변수로 지정
5. Intellij 우측 Gradle 클릭 후 새로고침
6. Intellij - Run - GitherbsApplication으로 실행
```

### Dockerfile (Back)

```docker
FROM openjdk:17-jdk
ADD ./build/libs/githerbs-0.0.1-SNAPSHOT.jar app.jar
ENTRYPOINT ["java", "-jar", "/app.jar"]
```

---

## Frontend Build

### .env

```
VITE_NAVER_CLIENT_KEY={Naver Map API의 Client ID}
```

### IDE 및 환경설정

```
1. Node.js 20.11.1 다운로드 및 환경변수 설정
2. git clone 후 frontend 폴더를 vscode에서 Open하여 가져오기
3. npm install
5. frontend 폴더 상위 경로에 .env 파일 위치시키기
6. npm run build
```

### Dockerfile (Front)

```docker
# 베이스 이미지로 Nginx 사용
FROM nginx:stable-alpine

# Nginx 설정 파일 복사
COPY nginx.conf /etc/nginx/conf.d/default.conf

# Jenkins에서 빌드된 결과물을 Nginx의 정적 파일 디렉토리로 복사
COPY ./dist /usr/share/nginx/html

# 포트 노출
EXPOSE 80

# 컨테이너 실행 시 Nginx 시작
CMD ["nginx", "-g", "daemon off;"]

```

### **.dockerignore** (Front)

```docker
node_modules
npm-debug.log
build
```

---

## Data Build

### 추천 약초 서버 배포

### IDE 및 환경설정 (윈도우 환경)

```
# 파이썬 설치
1. python (3.11) 설치 후 환경변수 설정

# 파이썬 가상환경 설정
1. 가상환경 설정할 폴더 생성
2. 폴더에서 python -m venv 가상환경이름 실행

# 파이썬 가상환경 진입
1. 가상환경안에 있는 Script에서 activate 명령어 실행
  (가상환경에서 벗어나고 싶은 경우는 같은 폴더에서 deactivate 실행)
2. 명령 프롬포트 왼쪽에 (가상환경이름) 이 붙어 있으면 진입 완료

# 라이브러리 설치
1. git clone 을 통해 받은 파일 중에서 requirements.txt 있는 폴더로 이동
2. pip install -r requirements.txt 명령어를 통해 필요한 라이브러리 설치
  (pip freeze > requirements.txt 은 다운받은 라이브러리 목록 txt로 저장)
 
# fastapi 실행
1. main.py 가 있는 폴더로 이동
2. uvicorn main:app --reload 로 fastapi 실행
```

### Dockerfile

```
FROM python:3.12.2

# JDK 설치
RUN apt-get update && \
    apt-get install -y default-jdk && \
    apt-get clean

# JAVA_HOME 환경 변수 설정
ENV JAVA_HOME /usr/lib/jvm/default-java
RUN export JAVA_HOME

WORKDIR /code

COPY ./requirements.txt /code/requirements.txt

RUN pip install --no-cache-dir --upgrade -r /code/requirements.txt

COPY ./main.py /code/
COPY ./recommender.py /code/
COPY herb_medicinal_effect.csv /code/

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "80"]
```

### Docker 실행

```
# 이미지 다시 빌드하기
docker build -t **이미지 이름** .

# 빌드 한 이미지 실행
docker run --name **컨테이너이름** -d -p **ec2에서접속할포트**:**Dockerfile에적힌포트** **이미지이름**

# 컨테이너 로그 확인
docker logs **컨테이너이름**
```

### 이미지 검색 서버


## 배포 파일 폴더 구조

```
📦githerbs
 ┣ 📂domain
 ┃ ┣ 📂auth
 ┃ ┃ ┣ 📂controller
 ┃ ┃ ┣ 📂dto
 ┃ ┃ ┃ ┣ 📂common
 ┃ ┃ ┃ ┣ 📂request
 ┃ ┃ ┃ ┗ 📂response
 ┃ ┃ ┣ 📂entity
 ┃ ┃ ┣ 📂repository
 ┃ ┃ ┗ 📂service
 ┃ ┣ 📂board
 ┃ ┃ ┣ 📂controller
 ┃ ┃ ┣ 📂dto
 ┃ ┃ ┃ ┣ 📂request
 ┃ ┃ ┃ ┗ 📂response
 ┃ ┃ ┣ 📂entity
 ┃ ┃ ┣ 📂repository
 ┃ ┃ ┗ 📂service
 ┃ ┣ 📂event
 ┃ ┃ ┣ 📂controller
 ┃ ┃ ┣ 📂dto
 ┃ ┃ ┃ ┣ 📂request
 ┃ ┃ ┃ ┗ 📂response
 ┃ ┃ ┣ 📂entity
 ┃ ┃ ┣ 📂repository
 ┃ ┃ ┗ 📂service
 ┃ ┣ 📂herb
 ┃ ┃ ┣ 📂controller
 ┃ ┃ ┣ 📂dto
 ┃ ┃ ┃ ┣ 📂request
 ┃ ┃ ┃ ┗ 📂response
 ┃ ┃ ┣ 📂entity
 ┃ ┃ ┣ 📂repository
 ┃ ┃ ┗ 📂service
 ┃ ┣ 📂manual
 ┃ ┃ ┣ 📂controller
 ┃ ┃ ┣ 📂dto
 ┃ ┃ ┃ ┗ 📂response
 ┃ ┃ ┣ 📂entity
 ┃ ┃ ┣ 📂repository
 ┃ ┃ ┗ 📂service
 ┃ ┣ 📂member
 ┃ ┃ ┣ 📂controller
 ┃ ┃ ┣ 📂dto
 ┃ ┃ ┃ ┣ 📂common
 ┃ ┃ ┃ ┣ 📂request
 ┃ ┃ ┃ ┗ 📂response
 ┃ ┃ ┣ 📂entity
 ┃ ┃ ┣ 📂repository
 ┃ ┃ ┗ 📂service
 ┃ ┗ 📂search
 ┃ ┃ ┣ 📂controller
 ┃ ┃ ┣ 📂dto
 ┃ ┃ ┃ ┗ 📂response
 ┃ ┃ ┣ 📂entity
 ┃ ┃ ┣ 📂repository
 ┃ ┃ ┗ 📂service
 ┣ 📂global
 ┃ ┣ 📂common
 ┃ ┃ ┣ 📂code
 ┃ ┃ ┣ 📂exception
 ┃ ┃ ┗ 📂response
 ┃ ┣ 📂config
 ┃ ┗ 📂handler
 ┗ 📜GitherbsApplication.java

```

```
📦frontend
 ┣ 📂public
 ┃ ┣ 📂grass
 ┃ ┣ 📂herbs
 ┃ ┣ 📂pediaimg
 ┃ ┣ 📂profileimg
 ┣ 📂src
 ┃ ┣ 📂apis
 ┃ ┣ 📂assets
 ┃ ┃ ┣ 📂fonts
 ┃ ┣ 📂components
 ┃ ┃ ┣ 📂board
 ┃ ┃ ┣ 📂escape
 ┃ ┃ ┣ 📂herbdetail
 ┃ ┃ ┣ 📂main
 ┃ ┃ ┣ 📂mypage
 ┃ ┃ ┣ 📂pedia
 ┃ ┃ ┣ 📂picture
 ┃ ┃ ┣ 📂search
 ┃ ┣ 📂pages
 ┃ ┣ 📂store
 ┃ ┣ 📂utils

```

```
📦data
 ┣ 📂image
 ┃ ┣ 📂model
 ┃ ┣ 📂notebook
 ┃ ┃ ┣ 📂output
 ┣ 📂search
```

# ⚙️ Server Settings

## Putty

- MobaXterm을 통해 EC2 서버에 접속

```
1. 좌측 상단의 Session - SSH 클릭
2. 필요 정보 입력
	- 1. Remote Host: EC2 Domain 입력
	- 2. Specify username: 체크 후 ubuntu 입력
3. Advanced SSH settings 탭 클릭
4. 필요 정보 입력
	- 1. Use private key 체크 후 .pem 파일 첨부
5. Bookmark settings - Session name에서 원하는 서버 이름 입력
```

## Server Default Setting

- 한국 표준시로 변경

```bash
sudo timedatectl set-timezone Asia/Seoul
```

- 패키지 목록 업데이트 및 패키지 업데이트

```bash
sudo apt-get -y update && sudo apt-get -y upgrade
```

## Docker Setting

- Docker 설치 전 필요한 패키지 설치

```bash
sudo apt-get -y install apt-transport-https ca-certificates curl gnupg-agent software-properties-common
```

- amd / arm 확인

```bash
dpkg -s libc6 | grep Arch
```

- 위에 해당하는 계열로 Docker 레포지토리 등록
임의로 amd / arm ⇒ ver로 작성

```bash
sudo add-apt-repository "deb [arch=ver64] https://download.docker.com/linux/ubuntu$(lsb_release -cs) stable"
```

- 패키지 리스트 갱신

```bash
sudo apt-get -y update
```

- Docker 패키지 설치

```bash
sudo apt-get -y install docker-ce docker-ce-cli containerd.io
```

- Docker 서비스 재시작

```bash
sudo service docker restart
exit
```

## SSL Setting

- nginx를 설치

```bash
sudo apt-get -y install nginx
```

- CertBot 다운로드

```bash
sudo snap install --classic certbot
```

- SSL 인증서 발급

```bash
sudo nginx --nginx -d my.domain.com
이후에 이메일 주소 입력
```

## Mysql & Redis

```yaml
version: '3.1'
services:
  mysql:
    image: mysql:8.0
    container_name: mysql
    ports:
      - 3306:3306 # HOST:CONTAINER
    environment:
      MYSQL_ROOT_PASSWORD: {mysql-password}
    command:
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_unicode_ci
    volumes:
      - /home/ubuntu/docker-compose/mysql/mysql:/var/lib/mysql
    restart: always
  
  redis:
    image: redis
    container_name: redis
    ports:
      - 6379:6379
    volumes:
      - /home/ubuntu/docker-compose/redis/data:/data
      - /home/ubuntu/docker-compose/redis/redis:/usr/local/etc/redis
    command: redis-server /usr/local/etc/redis/redis.conf
```

- [https://raw.githubusercontent.com/redis/redis/7.2/redis.conf](https://raw.githubusercontent.com/redis/redis/7.2/redis.conf) 접속 후 파일 다운로드, 수정

```
# redis.conf
bind 127.0.0.1 -::1 -> bind * -::*
requirepass ->  {레디스 비밀번호}
```

## Jenkins

- docker-compose.yml 작성

```
version: '3'

services:
  jenkins:
    image: jenkins/jenkins:latest-jdk17
    privileged: true
    user: root
    ports:
      - 포트번호!!!:8080
    container_name: 컨테이너이름!!!!
    volumes:
      - ./jenkins_home:/var/jenkins_home
    restart: unless-stopped
    command: bash -c "apt-get update && apt-get install -y docker.io && jenkins.sh"
```

- docker-compose up -d 실행 후

```
docker logs 컨테이너이름!!! 실행 그 안에서 토큰이 등장
지정된 포트로 접속 후 토큰을 입력 하면 기본 설정 페이지가 등장
id와 password 설정 후 기본 플러그인 다운로드 진행
```

- 추가 플러그인 설치

```
SSH Agent

Docker
Docker Commons
Docker Pipeline
Docker API

Generic Webhook Trigger

GitLab
GitLab API,
GitLab Authentication

NodeJS

Mattermost Notification
```

- 새로운 item으로 back front 아이템 생성

```
1. 생성 후 Build Triggers안에 Build when a change is pushed to GitLab. GitLab webhook URL: 체크 후 URL 복사
2. push Events와 Opened Merge Request Events 체크
3. 고급을 선택 후 Secret token Generate 실행 후 복사
4. 깃랩 접속 후 프로젝트 선택 → Settings → Webhooks 접속
5. add new webhook 선택 후 jenins에서 복사한 URL 입력
6. Secret token에 복사했던 Secret token 입력
7. 트리거에 push events 선택 후 저장
```

## Docker Hub Setting

- Docker Hub Token 발급

```
1. 우측 상단의 Sign in 버튼을 클릭하여 로그인
2. 우측 상단의 계정명을 클릭하여 Account Settings 클릭
3. New Access Token - Read,Write,Delete 권한을 가진 Token 발급
4. Token 값 저장
```

- Docker Hub Repository 생성

```
1. 상단의 Repositories - Create repository 클릭
2. Visibility 지정 후 Create 클릭
```

## Jenkins Pipeline Setting

- 플러그인 설치
    - Jenkins 관리 - Plugins - Available Plugins - 선택 후 Install without restart 클릭

```
SSH Agent

Docker
Docker Commons
Docker Pipeline
Docker API

Generic Webhook Trigger

GitLab
GitLab API,
GitLab Authentication

NodeJS

Mattermost Notification
```

- Docker Hub Credential 등록
    - Jenkins 관리 - Credentials - global - Add Credentials - Create

```
Kind: Username with password
Username: Docker Hub에서 사용하는 ID
Password: Docker Hub에서 사용하는 Token 값
ID: Credential에 대한 별칭
```

- GitLab Credential 등록
    - Jenkins 관리 - Credentials - global - Add Credentials - Create

```
Kind: Username with password
Username: GitLab 계정 아이디 입력
Password: GitLab 계정 비밀번호
ID: Credential에 대한 별칭
```

- Ubuntu Credential 등록
    - Jenkins 관리 - Plugins - Available Plugins - SSH Agent
    - Jenkins 관리 - Credentials - global - Add Credentials - Create

```
Kind: Username with private key
ID: Credential에 대한 별칭
Username: SSH 원격 서버 호스트에서 사용하는 계정명(ubuntu)
====> Enter directly - Add 클릭
.pem 키의 내용을 메모장을 읽어 복사 후 Key에 붙여넣은 후 Create
```

- logback 등록

```
Kind: Secret file
ID: Credential에 대한 별칭
file : logback-spring.xml 선택 후 create
```

```
<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <include resource="org/springframework/boot/logging/logback/defaults.xml"/>
    <include resource="org/springframework/boot/logging/logback/console-appender.xml" />
    <springProperty scope="context" name="application_name" source="spring.application.name"/>

    <appender name="LOGSTASH" class="net.logstash.logback.appender.LogstashTcpSocketAppender">
        <destination>{로그 스태시 주소}:{로그 스태시 포트}</destination>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <customFields>{"app_name":"${application_name}"}</customFields>
            <includeMdcKeyName>METHOD</includeMdcKeyName>
            <includeMdcKeyName>URI</includeMdcKeyName>
            <includeMdcKeyName>PARAMS</includeMdcKeyName>
            <fieldNames>
                <timestamp>timestamp</timestamp>
                <message>message</message>
                <thread>thread</thread>
                <level>level</level>
                <stackTrace>stack_trace</stackTrace>
            </fieldNames>
            <stackTraceConfiguration>
                <throwableConverter class="net.logstash.logback.stacktrace.ShortenedThrowableConverter">
                    <maxDepthPerThrowable>30</maxDepthPerThrowable>
                    <maxLength>2048</maxLength>
                    <shortenedClassNameLength>20</shortenedClassNameLength>
                    <exclude>^sun\.reflect\..*\.invoke</exclude>
                    <exclude>^net\.sf\.cglib\.proxy\.MethodProxy\.invoke</exclude>
                    <rootCauseFirst>true</rootCauseFirst>
                </throwableConverter>
            </stackTraceConfiguration>
        </encoder>
    </appender>

    <root level="INFO">
        <appender-ref ref="LOGSTASH"/>
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```

- Gradle 추가
    - Jenkins 관리 - Tools

```
name: gradle
Install automatically 체크
프로젝트 버전에 맞는 Gradle 선택 후 Save
```


# 💽 Data Import

```
1. Mysql Workbench 접속
2. 데이터베이스와 연결
3. 상단의 server - Data Import 선택
4. Import from Self-Contained File 선택 후 sql 파일 선택
5. Default Target Schema에서 사용할 Schema 선택
6. Start Import 선택
```

# 🎬 Deployment Command

## Pipeline (Back)

```bash
pipeline {
    agent any
    
    environment {
        imagename = "dockerhub repo 이름" // 사용자명/repo명
        registryCredential = 'dockerhub' // docker hub credential ID
        dockerImage = ''
        releaseServerAccount = 'ubuntu'
        releaseServerUri = 'i11a409.p.ssafy.io'
        // releasePort = '8080' // Spring boot는 8080 포트
    }
    
    tools {
        gradle 'gradle'
    }
    
    stages {
        stage('clone') {
            steps {
                git branch: '브랜치명', credentialsId: 'credential명', url: 'https~.git 형식의 Git 주소소'
            }
        }
        stage('back_build') {
            steps {
                dir('kiot') { // 하위의 'kiot' 디렉토리로 이동
                    sh "chmod +x gradlew"
                    sh "./gradlew clean bootJar"
                }
            }
        }
        stage('docker-build'){
            steps {
                dir('kiot'){
                    script {
                        docker.withRegistry('', registryCredential) {
                        sh "docker buildx create --use --name mybuilder"
                        sh "docker buildx build --platform linux/amd64,linux/arm64 -t $imagename:$BUILD_NUMBER --push ."
                        sh "docker buildx build --platform linux/amd64,linux/arm64 -t $imagename:latest --push ."
                    }
                    }
                }
            }
        }
        
        stage('Before Service Stop') {
            steps {
                sshagent(credentials: ['CommonEC2']) {
                    sh '''
                    if test "`ssh -o StrictHostKeyChecking=no $releaseServerAccount@$releaseServerUri "docker ps -aq --filter ancestor=$imagename:latest"`"; then
                    ssh -o StrictHostKeyChecking=no $releaseServerAccount@$releaseServerUri "docker stop $(docker ps -aq --filter ancestor=$imagename:latest)"
                    ssh -o StrictHostKeyChecking=no $releaseServerAccount@$releaseServerUri "docker rm -f $(docker ps -aq --filter ancestor=$imagename:latest)"
                    ssh -o StrictHostKeyChecking=no $releaseServerAccount@$releaseServerUri "docker rmi $imagename:latest"
                    fi
                    '''
                }
            }
        }
        stage('SSH-Server-EC2'){
            steps {
                echo 'SSH'
                
                sshagent(credentials: ['CommonEC2']) {
                    
                    sh 'ssh -o StrictHostKeyChecking=no ubuntu@i11a409.p.ssafy.io "docker pull ennw00/kiotserver:latest"'
                    sh 'ssh -o StrictHostKeyChecking=no $releaseServerAccount@$releaseServerUri "sudo docker run -d -i -v ~/keystore_dev.p12:/app/keystore_dev.p12 --env-file ~/.env --name kiotserver -p 8443:8443 $imagename:latest"'
                } 
            }
        }
    }
}
```

## Pipeline (Flask)

```bash
pipeline {
    agent any
    
    environment {
        imagename = "dockerhub repo 이름" // ex: 사용자명/repo명
        registryCredential = 'dockerhub'
        dockerImage = ''
        releaseServerAccount = 'ubuntu'
        releaseServerUri = 'i11a409.p.ssafy.io'
        // releasePort = '5000' // Flask의 포트는 5000
    }
    
    stages {
        stage('clone') {
            steps {
                git branch: '브랜치명', credentialsId: 'gitlabClaire', url: 'https://lab.ssafy.com/s11-webmobile2-sub2/S11P12A409.git'
            }
        }
        
        stage('docker-build'){
            steps {
                dir('Flask'){ // flask 브랜치 > Flask 폴더로 진입
                    script {
                        docker.withRegistry('', registryCredential) {
                        sh "docker buildx create --use --name mybuilder"
                        sh "docker buildx build --platform linux/amd64,linux/arm64 -t $imagename:$BUILD_NUMBER --push ."
                        sh "docker buildx build --platform linux/amd64,linux/arm64 -t $imagename:latest --push ."
                    }
                    }
                }
            }
        }
        stage('Before Service Stop') {
            steps {
                sshagent(credentials: ['CommonEC2']) {
                    sh '''
                    if test "`ssh -o StrictHostKeyChecking=no $releaseServerAccount@$releaseServerUri "docker ps -aq --filter ancestor=$imagename:latest"`"; then
                    ssh -o StrictHostKeyChecking=no $releaseServerAccount@$releaseServerUri "docker stop $(docker ps -aq --filter ancestor=$imagename:latest)"
                    ssh -o StrictHostKeyChecking=no $releaseServerAccount@$releaseServerUri "docker rm -f $(docker ps -aq --filter ancestor=$imagename:latest)"
                    ssh -o StrictHostKeyChecking=no $releaseServerAccount@$releaseServerUri "docker rmi $imagename:latest"
                    fi
                    '''
                }
            }
        }
        stage('SSH-Server-EC2'){
            steps {
                echo 'SSH'
                
                sshagent(credentials: ['CommonEC2']) {
                    
                    sh 'ssh -o StrictHostKeyChecking=no ubuntu@i11a409.p.ssafy.io "docker pull ennw00/kiotflask:latest"'
                    sh 'ssh -o StrictHostKeyChecking=no $releaseServerAccount@$releaseServerUri "sudo docker run -d -i -e TZ=Asia/Seoul -e PYANNOTE_TOKEN=토큰값 -e SECRET_KEY=시크릿키 값 --name kiotflask -p 5000:5000 $imagename:latest"'
                    
                } 
            }
        }
    }
}
```
